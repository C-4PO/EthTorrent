'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._getNetVersion = exports._getRPCInfo = exports._validateSecureOrigin = exports._validateParams = exports._popup = exports._fetch = exports._serialize = undefined;

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _config = require('./config');

var _error = require('./error');

var _popup2 = require('./popup');

var _popup3 = _interopRequireDefault(_popup2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SCOPES = ['wallets:admin', 'wallets:edit', 'wallets:create', 'wallets:remove', 'wallets:read', 'user', 'user:name', 'user:email', 'user:security'];

/**
 * URL-encodes a request object
 * @param {object} obj
 */
/* eslint-disable */
var _serialize = exports._serialize = function _serialize(obj) {
  return encodeURIComponent((0, _stringify2.default)(obj));
};

/**
 * Creates and executes GET Request
 * @param {string} url
 */
var _fetch = exports._fetch = function _fetch(url) {
  return new _promise2.default(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();
    xhr.onload = function () {
      if (xhr.status != 200) {
        reject(new _error.SqlkError('Issue connecting to Squarelink servers'));
      } else {
        resolve(JSON.parse(xhr.response));
      }
    };
    xhr.onerror = function () {
      reject(new _error.SqlkError('Issue connecting to Squarelink servers'));
    };
  });
};

/**
 * Creates Squarelink popup and returns posted result
 * @param {string} url
 */
var _popup = exports._popup = function _popup(url) {
  var _this = this;

  return new _promise2.default(function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(resolve, reject) {
      var _ref2, popup, iframe, error, result, popupTick;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, _popup3.default)(url);

            case 2:
              _ref2 = _context.sent;
              popup = _ref2.popup;
              iframe = _ref2.iframe;
              error = _ref2.error;

              if (!error) {
                _context.next = 8;
                break;
              }

              return _context.abrupt('return', resolve({ error: 'Window closed' }));

            case 8:
              result = false;


              if (popup) {
                // Poll to check if popup has been closed
                popupTick = setInterval(function () {
                  if (result) {
                    clearInterval(popupTick);
                  } else if (popup.closed) {
                    result = true;
                    window.removeEventListener('message', function () {});
                    clearInterval(popupTick);
                    resolve({ error: 'Window closed' });
                    var preloader = document.getElementById('squarelink-preloader-container');
                    preloader.parentNode.removeChild(preloader);
                  }
                }, 1);
              }

              if (iframe) {
                iframe.onClosed = function (error) {
                  if (!result) {
                    result = true;
                    window.removeEventListener('message', function () {});
                    resolve({ error: error || 'Window closed' });
                  }
                };
              }

              window.addEventListener('message', function (e) {
                var _e$data = e.data,
                    origin = _e$data.origin,
                    height = _e$data.height,
                    type = _e$data.type;

                if (type === 'onload') return;
                if (origin === 'squarelink' && !result) {
                  result = true;
                  window.removeEventListener('message', function () {});
                  if (popup) {
                    popup.close();
                    var preloader = document.getElementById('squarelink-preloader-container');
                    preloader.parentNode.removeChild(preloader);
                  } else {
                    iframe.close();
                  }
                  resolve((0, _extends3.default)({}, e.data, { origin: undefined, height: undefined }));
                }
              }, false);

            case 12:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
};

/**
 * Validates Squarelink inputs
 * @param {string} client_id
 * @param {string|object} [network]
 * @param {array} [scope]
 */
var _validateParams = exports._validateParams = function _validateParams(_ref3) {
  var client_id = _ref3.client_id,
      network = _ref3.network,
      scope = _ref3.scope;

  if (scope) {
    if (!Array.isArray(scope)) throw new _error.SqlkError('\'scope\' must be an Array');
    for (var i in scope) {
      if (!SCOPES.includes(scope[i])) throw new _error.SqlkError('We do not support the ' + scope[i] + ' scope');
    }
  }
  if ((typeof network === 'undefined' ? 'undefined' : (0, _typeof3.default)(network)) === 'object') {
    if (!network.url) throw new _error.SqlkError('Please provide an RPC endpoint for your custom network');else if (!network.url.match(/(wss|https){1}?:(\/?\/?)[^\s]+/)) throw new _error.SqlkError('We do not currently support insecure (http://, ws://) RPC connections. Try updating squarelink to its latest version!');else if (network.chainId && (network.chainId !== parseInt(network.chainId) || network.chainId < 0 || network.chainId > 500000)) throw new _error.SqlkError('Please provide a valid Chain ID');else if (network.skipCache !== undefined && typeof network.skipCache !== 'boolean') throw new _error.SqlkError('the `skipCache` paramter must be a boolean');
  } else if (!this.NETWORKS[network]) {
    throw new _error.SqlkError('Invalid network provided');
  } else if (!!this.NETWORKS[network].sdkVersion) {
    var sdkVersion = this.NETWORKS[network].sdkVersion;

    var sdkParts = _config.VERSION.split('.');
    var netParts = sdkVersion.split('.');
    for (var _i = 0; _i < 3; _i++) {
      if (parseInt(sdkParts[_i]) > parseInt(netParts[_i])) return;
      if (parseInt(sdkParts[_i]) < parseInt(netParts[_i])) {
        throw new _error.SqlkError('You need to update Squarelink to squarelink@' + sdkVersion + ' to use that network');
      }
    }
  }
};

/**
 * Notifies developer that their app won't work if on an insecure origin
 */
var _validateSecureOrigin = exports._validateSecureOrigin = function _validateSecureOrigin() {
  var isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  var isSecureOrigin = location.protocol === 'https:';
  var isChromeExt = location.protocol === 'chrome-extension:';
  var isSecure = isLocalhost || isSecureOrigin || isChromeExt;

  if (!isSecure) {
    throw new _error.SqlkError('Access to the Squarelink Web3 Engine is restricted to secure origins.\nIf this is a development environment please use http://localhost:' + location.port + ' instead.\nOtherwise, please use an SSL certificate.');
  }
};

/**
 * Gets RPC info from network parameter
 * @param {string|object} network
 */
var _getRPCInfo = exports._getRPCInfo = function _getRPCInfo(network) {
  var rpcUrl;
  var skipCache = true;
  if ((typeof network === 'undefined' ? 'undefined' : (0, _typeof3.default)(network)) === 'object') {
    rpcUrl = network.url;
    skipCache = network.skipCache !== undefined ? network.skipCache : true;
  } else {
    var netInfo = this.NETWORKS[network];
    rpcUrl = netInfo.rpcUrl;
    skipCache = netInfo.skipCache !== undefined ? netInfo.skipCache : true;
  }
  var protocol = rpcUrl.split(':')[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
      return {
        rpcUrl: rpcUrl,
        skipCache: skipCache,
        connectionType: 'http'
      };
    case 'ws':
    case 'wss':
      return {
        rpcUrl: rpcUrl,
        skipCache: skipCache,
        connectionType: 'ws'
      };
    default:
      throw new _error.SqlkError('Unrecognized protocol in "' + rpcUrl + '"');
  }
};

/**
 * Get the current network version
 * @param {string|object} network
 */
var _getNetVersion = exports._getNetVersion = function _getNetVersion(network) {
  if ((typeof network === 'undefined' ? 'undefined' : (0, _typeof3.default)(network)) === 'object') return network.chainId || null;
  return this.NETWORKS[network].chainId;
};
//# sourceMappingURL=util.js.map