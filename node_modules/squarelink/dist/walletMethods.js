'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._signTx = exports._signMsg = exports._getAccounts = undefined;

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _util = require('./util');

var _error = require('./error');

var _config = require('./config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Get a list of the users Ethereum accounts
 * @param {string} clientId
 * @param {object} opts
 */
var _getAccounts = function _getAccounts(client_id) {
  var _this = this;

  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var scope = { 'wallets:read': 1 };
  if (opts.scope && opts.scope.length) {
    opts.scope.forEach(function (s) {
      return scope[s] = 1;
    });
  }
  scope = (0, _keys2.default)(scope).toString().replace(/ /g, '');
  return new _promise2.default(function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(resolve, reject) {
      var url, params;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              url = _config.APP_URL + '/authorize?version=' + _config.VERSION;
              params = {
                version: _config.VERSION,
                client_id: client_id,
                scope: '[' + scope + ']',
                response_type: 'token',
                widget: true
              };

              (0, _util._popup)({ url: url, params: params }).then(function (_ref2) {
                var error = _ref2.error,
                    result = _ref2.result;

                if (error) reject(new _error.SqlkError(error));else {
                  var promises = [];
                  promises.push((0, _util._fetch)(_config.API_ENDPOINT + '/wallets?access_token=' + result).then(function () {
                    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref3) {
                      var success = _ref3.success,
                          wallets = _ref3.wallets;
                      return _regenerator2.default.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (success) {
                                _context.next = 4;
                                break;
                              }

                              reject(new _error.SqlkError(data.message || 'Issue fetching accounts, try again later'));
                              _context.next = 5;
                              break;

                            case 4:
                              return _context.abrupt('return', _promise2.default.resolve({
                                accounts: [wallets.find(function (w) {
                                  return w.default;
                                })].concat((0, _toConsumableArray3.default)(wallets.filter(function (w) {
                                  return !w.default;
                                }))).map(function (w) {
                                  return w.address;
                                })
                              }));

                            case 5:
                            case 'end':
                              return _context.stop();
                          }
                        }
                      }, _callee, _this);
                    }));

                    return function (_x4) {
                      return _ref4.apply(this, arguments);
                    };
                  }()).catch(function (err) {
                    return reject(err);
                  }));
                  if (scope !== 'wallets:read') {
                    promises.push((0, _util._fetch)(_config.API_ENDPOINT + '/user?access_token=' + result).then(function () {
                      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_ref5) {
                        var success = _ref5.success,
                            user = (0, _objectWithoutProperties3.default)(_ref5, ['success']);
                        return _regenerator2.default.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                if (success) {
                                  _context2.next = 4;
                                  break;
                                }

                                reject(new _error.SqlkError(data.message || 'Issue fetching user info, try again later'));
                                _context2.next = 5;
                                break;

                              case 4:
                                return _context2.abrupt('return', _promise2.default.resolve({
                                  securitySettings: {
                                    has2fa: user.has_2fa,
                                    hasRecovery: user.has_recovery,
                                    emailVerified: user.email_verified
                                  },
                                  name: user.given_name + ' ' + user.family_name,
                                  email: user.email
                                }));

                              case 5:
                              case 'end':
                                return _context2.stop();
                            }
                          }
                        }, _callee2, _this);
                      }));

                      return function (_x5) {
                        return _ref6.apply(this, arguments);
                      };
                    }()).catch(function (err) {
                      return reject(err);
                    }));
                  }
                  _promise2.default.all(promises).then(function (results) {
                    var result = {};
                    results.forEach(function (r) {
                      result = (0, _extends3.default)({}, result, r);
                    });
                    resolve(result);
                  });
                }
              });

            case 3:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function (_x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }());
};

/**
 * Request a signed message from a user
 * @param {string} client_id
 * @param {string} message
 * @param {string} method
 * @param {string} account
 */
/* eslint-disable */
exports._getAccounts = _getAccounts;
var _signMsg = exports._signMsg = function () {
  var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(_ref7) {
    var client_id = _ref7.client_id,
        message = _ref7.message,
        method = _ref7.method,
        account = _ref7.account;
    var url, params;
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            url = _config.APP_URL + '/msg?version=' + _config.VERSION;
            params = {
              client_id: client_id,
              method: method,
              version: _config.VERSION,
              account: account
            };

            if (method === 'eth_signTypedData') {
              params.params = message;
            } else if (method === 'eth_signTypedData_v3') {
              params.paramsV3 = message;
            } else {
              params.msg = message;
            }
            return _context4.abrupt('return', (0, _util._popup)({ url: url, params: params }).then(function (_ref9) {
              var error = _ref9.error,
                  result = _ref9.result;

              if (error) throw new _error.SqlkError(error);
              return _promise2.default.resolve(result);
            }));

          case 4:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function _signMsg(_x6) {
    return _ref8.apply(this, arguments);
  };
}();

/**
 * Request a signed transaction from a user
 * @param {string} method
 * @param {string} client_id
 * @param {string} value
 * @param {string} to
 * @param {string} from
 * @param {string} gas
 * @param {string} gasPrice
 * @param {string} nonce
 * @param {string} network
 * @param {string} description
 * @param {string} state
 * @param {string} data
 */
var _signTx = exports._signTx = function () {
  var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(_ref10) {
    var method = _ref10.method,
        client_id = _ref10.client_id,
        value = _ref10.value,
        to = _ref10.to,
        from = _ref10.from,
        gas = _ref10.gas,
        gasPrice = _ref10.gasPrice,
        nonce = _ref10.nonce,
        network = _ref10.network,
        description = _ref10.description,
        state = _ref10.state,
        data = _ref10.data;
    var url, params;
    return _regenerator2.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (to) {
              _context5.next = 2;
              break;
            }

            throw new _error.SqlkError('You must provide a recipient `to` for the request');

          case 2:
            url = _config.APP_URL + '/tx?widget=true&version=' + _config.VERSION;
            params = {
              method: method,
              client_id: client_id,
              version: _config.VERSION,
              widget: true,
              to: to,
              from: from,
              data: data,
              state: state,
              description: description
            };

            if (value) params.value = parseInt(value, 16);
            if (gas) params.gas = parseInt(gas, 16);
            if (gasPrice) params.gasPrice = parseInt(gasPrice, 16);
            if (nonce) params.nonce = parseInt(nonce, 16);
            // set network
            if ((typeof network === 'undefined' ? 'undefined' : (0, _typeof3.default)(network)) === 'object') {
              params.network = 'custom';
              params.rpc_url = network.url;
              if (network.chainId) params.chain_id = network.chainId;
            } else {
              params.network = network;
            }
            return _context5.abrupt('return', (0, _util._popup)({ url: url, params: params }).then(function (_ref12) {
              var error = _ref12.error,
                  result = _ref12.result;

              if (error) throw new _error.SqlkError(error);
              return _promise2.default.resolve(result);
            }));

          case 10:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, this);
  }));

  return function _signTx(_x7) {
    return _ref11.apply(this, arguments);
  };
}();
//# sourceMappingURL=walletMethods.js.map